/* App.svelte generated by Svelte v3.12.1 */

// The package svelte/internal defines many helper functions.
// This code can be found in node_modules/svelte/internal/index.js.
// The ones that are used end up in the bundle
// when the app is built for deployment.
import {
  SvelteComponent,
  append,
  detach,
  element,
  init,
  insert,
  listen,
  noop,
  safe_not_equal,
  set_data,
  set_input_value,
  space,
  text
} from 'svelte/internal';

// This function is passed to the init function
// that is called in the component constructor below.
// It returns an object with many methods
// that have single-letter names.
// The "ctx" parameter is a object that holds the current component state.
// A better name for this would have been "state" since Svelte
// has another kind of context that is different from this.
// It is composed of the values of all top-level variables
// in the component that are used in the HTML.
// In this case it is just "name".
// It does not include "unused" because that is not used in the HTML.
//TODO: VERIFY THIS!
function create_fragment(ctx) {
  // These variables are set by the "c" method below,
  // and used by the other methods.
  // When only one of a given kind of element is used,
  // the variable that holds the instance has the same name as the element.
  // When there is more than one, a number starting
  // from zero is added to the end of the name.
  // Text nodes are named "t" followed by a number starting from one.
  // Heading elements are named "h" followed by a number starting from one.
  // dispose is a function that unregisters an event listener.
  var label, t1, input, t2, h1, t3, t4, t5, dispose;

  return {
    // The "c" method name is short for create.
    // This method creates all the DOM node instances
    // needed to create the HTML in the .svelte file.
    // Note that none are appended to their parent yet.
    c() {
      label = element('label');
      label.textContent = 'Name';
      t1 = space();
      input = element('input');
      t2 = space();
      h1 = element('h1');
      t3 = text('Hello ');
      t4 = text(ctx.name);
      t5 = text('!');

      // This registers an event listener and saves a function
      // that will remove the event listener later.
      // When there is more than one event listener, "dispose" is set to
      // an array of functions that each remove one of the event listeners.
      dispose = listen(input, 'input', ctx.input_input_handler);
    },

    // The "m" method name is short for mount.
    // The parameter "target" is a DOM element to which this component should be attached.
    // The parameter "anchor" is a DOM node child of "target" that this component should precede.
    // When not supplied, this component is added as the new last child of "target".
    // This method appends all the top-level nodes of this component to the target element
    // and appends all the non-top-level nodes of this component to their correct parent.
    // It also sets the values of elements that use the component state.
    m(target, anchor) {
      // The top-level nodes in this example are label, t1, input, t2, and h1.
      insert(target, label, anchor);
      insert(target, t1, anchor);
      insert(target, input, anchor);

      set_input_value(input, ctx.name);

      insert(target, t2, anchor);
      insert(target, h1, anchor);
      append(h1, t3);
      append(h1, t4);
      append(h1, t5);
    },

    // The "p" method updates only the parts of the DOM
    // of this component that have changed.
    // In the past there were "update" and "unmount" operations.
    // "unmount" was given the short name "u",
    // so "update" was given the short name "p".
    // The "unmount" operation was replaced by "destroy",
    // but the "update" operation has continued to be called "p".
    // This approach is much more efficient that the
    // process required when using a virtual DOM.
    // The "changed" parameter is an object where the keys are component state names
    // and the values are booleans indicating whether they have changed.
    // The "ctx" parameter is an object where the keys are component state names
    // and the values are their current values.
    p(changed, ctx) {
      if (changed.name && input.value !== ctx.name)
        set_input_value(input, ctx.name);

      if (changed.name) {
        set_data(t4, ctx.name);
      }
    },

    // The "i" method name is short for "intro".
    // It runs code that is registered to run before animations.
    // It does nothing in this component because it doesn't use animations.
    i: noop,

    // The "o" method name is short for "outro".
    // It runs code that is registered to run after animations.
    // It does nothing in this component because it doesn't use animations.
    o: noop,

    // The "d" method name is short for "destroy".
    // If the "detaching" parameter is true,
    // it detaches all the top-level nodes from their parent
    // and unregisters all event listeners by calling dispose.
    d(detaching) {
      if (detaching) {
        detach(label);
        detach(t1);
        detach(input);
        detach(t2);
        detach(h1);
      }

      // When "dispose" is an array of functions, this line is replaced
      // with run_all(dispose) which calls each of the function.
      dispose();
    }
  };
}

let unused = 'not used';

// This function is passed to the init function
// that is called in the component constructor below.
// The $$invalidate parameter is a function that can be called
// to mark a given piece of component state as changed.
function instance($$self, $$props, $$invalidate) {
  let name = 'world';

  function input_input_handler() {
    name = this.value;
    // The $$invalidate function which is passed into the "instance" function
    // sets changed.name to true and ctx.name to the new value
    // if the value was really changed.
    $$invalidate('name', name);
  }

  // This becomes the initial value of $$.ctx
  // inside the "init" function in svelte/internal.
  // It includes one property for each state variable
  // and one property for each event handler function.
  // The event handler functions are used in the create method ("c") above
  // to register event listeners for form controls
  // like <input>, <select>, and <textarea>.
  return {name, input_input_handler};
}

class App extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, []);
  }
}

export default App;
